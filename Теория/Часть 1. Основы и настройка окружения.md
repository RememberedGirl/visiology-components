# **Часть 1: Основы и настройка окружения**


## 1.1 Введение в кастомные виджеты Visiology
### Что такое кастомные виджеты
### Сценарии использования

## 1.2 Настройка среды разработки
### Инструменты разработки  
Кастомные виджеты в Visiology разрабатываются через встроенный редактор JavaScript кода,
который доступен после включения опции "Разрешить редактирование кода" в разделе "Форматирование" → "Общее".

Ключевые особенности:

- Нет доступа к коду других виджетов: Невозможно напрямую взаимодействовать с JavaScript других виджетов
- Работа с HTML/CSS через JavaScript: Весь UI создается и управляется через JS код



### Структура проекта



- HTML

1
```js

const html  = `<div id="div-${w.general.renderTo}"></div>`;

$('#' + w.general.renderTo).html(html);

```

2
```js
w.general.text = `<div id="div-${w.general.renderTo}"></div>`;

// Отображаем через TextRender
TextRender({
text: w.general, 
style: {}
    
});
```

- CSS


```js
{
  const styleId = w.general.renderTo + 'style';
  const css = `
  
    .va-widget-header {    }
   
    `

  let style = document.getElementById(styleId);
  if (!style) {
    style = document.createElement('style');
    style.id = styleId;
    document.head.appendChild(style);
  }
  style.textContent = css;
}

```

- js

```js

{
    const scriptId = w.general.renderTo + 'script';
    const code = `
          // код библиотеки
        console.log('Библиотека загружена');
    `;
    
    
    if (!document.getElementById(scriptId)) {
        const script = document.createElement('script');
        script.id = scriptId;
        document.body.appendChild(script);
    }
    script.textContent = code;
}

```

- Данные

Данные содержатся в w. Что бы виджет мог влиять на другие виджеты используем visApi
```js

console.log(w)
visApi().setFilterSelectedValues( w.general.renderTo, [[keys[0] ], [keys[1] ] ])

```



##  1.3 Создание первого виджета
### Базовый шаблон

1
```js
// Данные из Visiology
const items = w.data.primaryData.items;
const keys = items[0].cols.slice(items[0].keys.length);
const categories = items.map(item => item.formattedKeys.join(' - '));

// Создаем серии
const series = keys.map((key, j) => ({
    name: key,
    data: items.map(item => item.values[j])
}));

// Рендерим и инициализируем график
Highcharts.chart(w.general.renderTo,
{ 
    xAxis: { categories },
    series 
    
});
```

3
```js
// Данные из Visiology
const items = w.data.primaryData.items;
const keys = items[0].cols.slice(items[0].keys.length);
const categories = items.map(item => item.formattedKeys.join(' - '));

// Получаем текущий фильтр
let currentFilter = visApi().getSelectedValues(w.general.renderTo).map(e => e.join(' - '))[0];

// Создаем серии
const series = keys.map((key, j) => ({
    name: key,
    data: items.map((item, index) => ({
        y: item.values[j],
        marker: {
            lineWidth: currentFilter === categories[index] ? 2 : 0,
            lineColor: '#000'
        }
    }))
}));



// Рендерим и инициализируем график
const chart = Highcharts.chart(w.general.renderTo,
    { 
        xAxis: { categories },
        series,
        plotOptions: {
            series: {
                point: {
                    events: {
                        click: function() {
                            const categoryArr = categories[this.index]
                            let category = []
                            if (currentFilter != categoryArr){ 
                                category = [categoryArr.split(' - ')]
                            } 
                            visApi().setFilterSelectedValues(w.general.renderTo, category);
                            
                            
                        }
                    }
                }
            }
        },
        
    });


visApi().onSelectedValuesChangedListener({guid: w.general.renderTo, widgetGuid: w.general.renderTo},


    function(event) {
        // Обновляем текущий фильтр из события
        currentFilter = event.selectedValues.map(e => e.join(' - '))[0];
    
    
    // Обновляем обводку всех точек
        chart.series.forEach((series, seriesIndex) => {
            series.data.forEach((point, pointIndex) => {
                point.update({
                    marker: {
                        lineWidth: currentFilter == categories[pointIndex] ? 2 : 0,
                        lineColor: '#000'
                    }
                }, false); // false - не перерисовывать сразу
            });
        });
        
        // Перерисовываем график один раз
        chart.redraw();
    
})   
    
    
    




```
