# **Часть 1: Основы и настройка окружения**


## 1.1 Введение в кастомные виджеты Visiology
### Что такое кастомные виджеты
### Сценарии использования

## 1.2 Настройка среды разработки
### Инструменты разработки  
Кастомные виджеты в Visiology разрабатываются через встроенный редактор JavaScript кода,
который доступен после включения опции "Разрешить редактирование кода" в разделе "Форматирование" → "Общее".

Ключевые особенности:

- Нет доступа к коду других виджетов: Невозможно напрямую взаимодействовать с JavaScript других виджетов
- Работа с HTML/CSS через JavaScript: Весь UI создается и управляется через JS код



### Структура проекта



- HTML

1
```js

const html  = `<div id="div-${w.general.renderTo}"></div>`;

$('#' + w.general.renderTo).html(html);

```

2
```js
w.general.text = `<div id="div-${w.general.renderTo}"></div>`;

// Отображаем через TextRender
TextRender({
text: w.general, 
style: {}
    
});
```

- CSS


```js
{
  const styleId = w.general.renderTo + 'style';
  const css = `
  
    .va-widget-header {    }
   
    `

  let style = document.getElementById(styleId);
  if (!style) {
    style = document.createElement('style');
    style.id = styleId;
    document.head.appendChild(style);
  }
  style.textContent = css;
}

```

- js

```js

{
    const scriptId = w.general.renderTo + 'script';
    const code = `
          // код библиотеки         
    `;
    
    
    if (!document.getElementById(scriptId)) {
        const script = document.createElement('script');
        script.id = scriptId;
        document.body.appendChild(script);
    }
    script.textContent = code;
}


- Данные

Данные содержатся в w. Что бы виджет мог влиять на другие виджеты используем visApi
```js

console.log(w)
visApi().setFilterSelectedValues( w.general.renderTo, [[keys[0] ], [keys[1] ] ])

```



##  1.3 Создание первого виджета
### Базовый шаблон

1
```js
// Данные из Visiology
const items = w.data.primaryData.items;
const keys = items[0].cols.slice(items[0].keys.length);
const categories = items.map(item => item.formattedKeys.join(' - '));

// Создаем серии
const series = keys.map((key, j) => ({
    name: key,
    data: items.map(item => item.values[j])
}));

// Рендерим и инициализируем график
Highcharts.chart(w.general.renderTo,
{ 
    xAxis: { categories },
    series 
    
});
```

3
```js
// Данные из Visiology
const items = w.data.primaryData.items;
const keys = items[0].cols.slice(items[0].keys.length);
const categories = items.map(item => item.formattedKeys.join(' - '));

// Получаем текущий фильтр
let currentFilter = visApi().getSelectedValues(w.general.renderTo).map(e => e.join(' - '))[0];

// Создаем серии
const series = keys.map((key, j) => ({
    name: key,
    data: items.map((item, index) => ({
        y: item.values[j],
        marker: {
            lineWidth: currentFilter === categories[index] ? 2 : 0,
            lineColor: '#000'
        }
    }))
}));



// Рендерим и инициализируем график
const chart = Highcharts.chart(w.general.renderTo,
    { 
        xAxis: { categories },
        series,
        plotOptions: {
            series: {
                point: {
                    events: {
                        click: function() {
                            const categoryArr = categories[this.index]
                            let category = []
                            if (currentFilter != categoryArr){ 
                                category = [categoryArr.split(' - ')]
                            } 
                            visApi().setFilterSelectedValues(w.general.renderTo, category);
                            
                            
                        }
                    }
                }
            }
        },
        
    });


visApi().onSelectedValuesChangedListener({guid: w.general.renderTo, widgetGuid: w.general.renderTo},


    function(event) {
        // Обновляем текущий фильтр из события
        currentFilter = event.selectedValues.map(e => e.join(' - '))[0];
    
    
    // Обновляем обводку всех точек
        chart.series.forEach((series, seriesIndex) => {
            series.data.forEach((point, pointIndex) => {
                point.update({
                    marker: {
                        lineWidth: currentFilter == categories[pointIndex] ? 2 : 0,
                        lineColor: '#000'
                    }
                }, false); // false - не перерисовывать сразу
            });
        });
        
        // Перерисовываем график один раз
        chart.redraw();
    
})   
    
    
    




```


4
```js
// Данные из Visiology
const items = w.data.primaryData.items;
const keys = items[0].cols.slice(items[0].keys.length);
const categories = items.map(item => item.formattedKeys.join(' - '));

// Получаем текущий фильтр
let currentFilter = visApi().getSelectedValues(w.general.renderTo).map(e => e.join(' - '))[0];

// Создаем данные для treemap
const treemapData = items.map((item, index) => ({
    name: categories[index],
    value: item.values[0], // берем первый показатель
    itemStyle: {
        borderWidth: currentFilter === categories[index] ? 3 : 1,
        borderColor: currentFilter === categories[index] ? '#ff0000' : '#000'
    }
}));

// Создаем контейнер для графика
const html = `<div id="treemap-${w.general.renderTo}" style="width:100%; height:100%;"></div>`;
TextRender({ text: { ...w.general, text: html }, style: {} });

// Инициализируем treemap
const chart = echarts.init(document.getElementById(`treemap-${w.general.renderTo}`));
chart.setOption({
    series: [{
        type: 'treemap',
        data: treemapData,
        roam: false,
        nodeClick: false,
        breadcrumb: { show: false }
    }]
});

// Обработчик клика
chart.on('click', function(params) {
    const categoryArr = params.name;
    let category = [];
    if (currentFilter != categoryArr) { 
        category = [categoryArr.split(' - ')];
    }
    visApi().setFilterSelectedValues(w.general.renderTo, category);
});

// Слушаем изменения фильтра
visApi().onSelectedValuesChangedListener(
    {guid: w.general.renderTo, widgetGuid: w.general.renderTo},
    function(event) {
        currentFilter = event.selectedValues.map(e => e.join(' - '))[0];
        
        // Обновляем границы
        chart.setOption({
            series: [{
                data: treemapData.map(item => ({
                    ...item,
                    itemStyle: {
                        borderWidth: currentFilter === item.name ? 3 : 1,
                        borderColor: currentFilter === item.name ? '#ff0000' : '#000'
                    }
                }))
            }]
        });
    }
);


```
5
```js
// Добавляем ecStat библиотеку однократно
{
    const scriptId = 'ecstat-library';
    if (!document.getElementById(scriptId)) {
        const script = document.createElement('script');
        script.id = scriptId;
        script.src = 'https://cdn.jsdelivr.net/npm/echarts-stat@1.2.0/dist/ecStat.min.js';
        document.head.appendChild(script);
    }
}

// Ждем загрузки ecStat
function initClustering() {
    if (typeof ecStat === 'undefined') {
        setTimeout(initClustering, 100);
        return;
    }

    // Данные из Visiology
    const items = w.data.primaryData.items;
    
    if (!items || items.length === 0) {
        console.log('Нет данных для кластеризации');
        return;
    }

    // Используем разные комбинации показателей для кластеризации
    const data = items.map((item, index) => [
        parseFloat(item.values[0]) || 0 + index * 0.1, // добавляем небольшую вариацию
        parseFloat(item.values[1]) || 0 + index * 0.1
    ]);

    // Простая кластеризация K-means
    const clusterResult = ecStat.clustering.hierarchicalKMeans(data, {
        clusterCount: Math.min(2, items.length) // уменьшаем количество кластеров
    });

    // Создаем контейнер для графика
    const html = `<div id="cluster-${w.general.renderTo}" style="width:100%; height:100%;"></div>`;
    TextRender({ text: { ...w.general, text: html }, style: {} });

    const chart = echarts.init(document.getElementById(`cluster-${w.general.renderTo}`));

    // Если кластеризация не удалась, показываем обычный scatter plot
    if (!clusterResult || !clusterResult.clusters) {
        console.log('Показываем обычный scatter plot');
        chart.setOption({
            xAxis: { type: 'value' },
            yAxis: { type: 'value' },
            series: [{
                type: 'scatter',
                data: data,
                itemStyle: {
                    color: w.colors[0]
                }
            }],
            tooltip: {
                formatter: function(params) {
                    const item = items[params.dataIndex];
                    return `${item.formattedKeys[0]}<br/>
                            X: ${params.value[0].toFixed(2)}<br/>
                            Y: ${params.value[1].toFixed(2)}`;
                }
            }
        });
        return;
    }

    // Показываем результат кластеризации
    const seriesData = clusterResult.clusters.map((cluster, clusterIndex) => ({
        name: `Кластер ${clusterIndex + 1}`,
        type: 'scatter',
        data: cluster.points ? cluster.points.map(point => point.coord) : [],
        itemStyle: {
            color: w.colors[clusterIndex % w.colors.length]
        }
    }));

    chart.setOption({
        xAxis: { type: 'value' },
        yAxis: { type: 'value' },
        series: seriesData,
        tooltip: {
            formatter: function(params) {
                return `Кластер: ${params.seriesName}<br/>
                        X: ${params.value[0].toFixed(2)}<br/>
                        Y: ${params.value[1].toFixed(2)}`;
            }
        }
    });
}

// Запускаем инициализацию
initClustering();


```