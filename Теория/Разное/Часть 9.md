# Полное руководство по интеграции кастомных визуализаций в Visiology

## 1. Структура данных Visiology (`w` объект)

### Общее описание
`w.data.primaryData.items` представляет собой массив объектов данных, сформированный в результате агрегации и группировки в OLAP-кубе системы бизнес-аналитики.

```javascript
w.data.primaryData.items = [
    { /* объект данных 1 */ },
    { /* объект данных 2 */ },
    // ... n объектов
]
```

### Структура элемента данных
```javascript
item = {
    "keys": Array,           // Массив ключей группировки
    "values": Array,         // Массив числовых значений метрик
    "items": Array,          // Массив для вложенных данных
    "metadata": Array,       // Метаданные о колонках
    "cols": Array,           // Порядок и названия колонок
    "formattedKeys": Array,  // Форматированные ключи для отображения
    "formattedValues": Array // Форматированные значения для отображения
}
```

### Детальное описание свойств

#### `keys: Array<string>`
**Назначение**: Ключи группировки (измерения)
- Содержит значения измерений, по которым производилась группировка данных
- Порядок элементов соответствует иерархии группировки
- Количество элементов может варьироваться в зависимости от уровня детализации

**Пример**:
```javascript
["Регион", "Город", "Клиент"]
```

#### `values: Array<number>`
**Назначение**: Числовые значения метрик
- Содержит агрегированные числовые показатели
- Порядок соответствует порядку метрик в `metadata`
- Типы данных: целые числа, числа с плавающей точкой

**Пример**:
```javascript
[1500.75, 450.50]
```

#### `items: Array`
**Назначение**: Контейнер для вложенных данных
- Обычно пустой массив на текущем уровне агрегации
- Может содержать дочерние элементы при детализации данных
- Используется для hierarchical data structures

#### `metadata: Array<Object>`
**Назначение**: Описание структуры данных метрик

**Структура объекта метаданных**:
```javascript
{
    "columnName": string,      // Техническое имя колонки
    "displayName": string,     // Отображаемое имя для UI
    "tableName": string,       // Исходная таблица в БД
    "dataType": string,        // Тип данных ("Double", "Integer", "String", etc.)
    "columnType": number,      // Тип колонки (0 - dimension, 1 - measure)
    "min": number|null,        // Минимальное значение (опционально)
    "max": number|null         // Максимальное значение (опционально)
}
```

#### `cols: Array<string>`
**Назначение**: Определяет порядок и состав колонок
- Содержит полный список полей в правильном порядке
- Включает как измерения (keys), так и метрики (values)
- Используется для построения таблиц и визуализаций

**Пример**:
```javascript
["region", "city", "customername", "sales_amount", "unit_price"]
```

#### `formattedKeys: Array<string>`
**Назначение**: Форматированные версии ключей для отображения
- Содержит human-readable представление значений из `keys`
- Может включать локализацию, форматирование дат, etc.
- Используется непосредственно в пользовательском интерфейсе

#### `formattedValues: Array<string>`
**Назначение**: Форматированные версии значений для отображения
- Содержит отформатированные строковые представления числовых значений
- Включает разделители тысяч, валютные символы, проценты, etc.
- Учитывает региональные настройки форматирования

## 2. Паттерн работы с фильтрами: GET → SET → LISTEN

### Базовый паттерн
```javascript
// Правильный паттерн: GET → SET → LISTEN
const widgetGuid = w.general.renderTo;
let currentFilter = '';

// 1. GET - один раз при загрузке
function init() {
    const initialFilters = visApi().getSelectedValues(widgetGuid);
    currentFilter = formatFilter(initialFilters);
    renderUI();
}

// 2. SET - при действии пользователя
function handleUserAction(newFilterValue) {
    const filterToSet = currentFilter === newFilterValue ? [] : [newFilterValue.split(' - ')];
    visApi().setFilterSelectedValues(widgetGuid, filterToSet);
}

// 3. LISTEN - для обновлений UI
visApi().onSelectedValuesChangedListener(
    {guid: widgetGuid + '-listener', widgetGuid: widgetGuid},
    (event) => {
        currentFilter = formatFilter(event.selectedValues);
        renderUI();
    }
);

function formatFilter(selectedValues) {
    return selectedValues && selectedValues.length > 0 
        ? selectedValues.map(e => e.join(' - '))[0] 
        : '';
}
```


## 3. Создание уникального контейнера и рендеринг

### Базовый подход
```javascript
// Добавляем уникальный guid в HTML для избежания конфликтов между виджетами
w.general.text = `<div id="widget-${w.general.renderTo}"></div>`;

// Отображаем через TextRender
TextRender({
    text: w.general, 
    style: {}
});
```

### Расширенный подход с обработкой загрузки
```javascript
function initializeWidget() {
    const widgetGuid = w.general.renderTo;
    
    // Создаем уникальный контейнер
    w.general.text = `<div id="my-widget-${widgetGuid}"></div>`;
    
    // Рендерим контейнер
    TextRender({
        text: w.general, 
        style: {}
    });
    
    
        const container = document.getElementById(`my-widget-${widgetGuid}`);
        if (container) {
            renderVisualization(container);
        } 
    
}

// Запуск инициализации
initializeWidget();
```

## 4. Подключение внешних библиотек

### Безопасное подключение скриптов
```javascript
function loadExternalLibrary() {
    const scriptId = w.general.renderTo + '-script';
    
    // Проверяем, не загружена ли библиотека
    if (!document.getElementById(scriptId)) {
        const script = document.createElement('script');
        script.id = scriptId;
        script.src = 'https://cdn.example.com/library.js'; // URL библиотеки
        script.onload = () => initializeVisualization();
        script.onerror = () => console.error('Failed to load library');
        document.body.appendChild(script);
    } else {
        initializeVisualization();
    }
}

// Или встроенный код библиотеки
{
    const scriptId = w.general.renderTo + 'script';
    const code = `
        // код библиотеки
        window.customChartLibrary = {
            createChart: function(container, data) {
                // реализация создания графика
            }
        };
    `;
    
    if (!document.getElementById(scriptId)) {
        const script = document.createElement('script');
        script.id = scriptId;
        document.body.appendChild(script);
    }
    script.textContent = code;
}
```

## 5. Полный пример интеграции

### Пример: Network Graph с фильтрацией
```javascript
// Загрузка Highcharts
{
    const scriptId = w.general.renderTo + '-highcharts';
    if (!document.getElementById(scriptId)) {
        const script = document.createElement('script');
        script.id = scriptId;
        script.src = 'https://code.highcharts.com/highcharts.js';
        document.head.appendChild(script);
    }
}

// Данные из Visiology
const items = w.data.primaryData.items;
const keys = items[0].cols.slice(items[0].keys.length);
const categories = items.map(item => item.formattedKeys.join(' - '));

// 1. GET - один раз при загрузке
let currentFilter = '';
const initialFilters = visApi().getSelectedValues(w.general.renderTo);
currentFilter = initialFilters.length > 0 ? initialFilters.map(e => e.join(' - '))[0] : '';

// Создаем серии
const series = keys.map((key, j) => ({
    name: key,
    data: items.map((item, index) => ({
        y: item.values[j],
        marker: {
            lineWidth: currentFilter === categories[index] ? 2 : 0,
            lineColor: '#000'
        }
    }))
}));

// Создаем контейнер для графика
w.general.text = `<div id="chart-${w.general.renderTo}" style="width:100%; height:100%;"></div>`;
TextRender({
    text: w.general,
    style: {}
});

// Рендерим и инициализируем график
const chart = Highcharts.chart(`chart-${w.general.renderTo}`, {
    xAxis: { categories },
    series,
    plotOptions: {
        series: {
            point: {
                events: {
                    click: function() {
                        // 2. SET - при действии пользователя
                        const categoryArr = categories[this.index];
                        let category = [];
                        if (currentFilter !== categoryArr) {
                            category = [categoryArr.split(' - ')];
                        }
                        visApi().setFilterSelectedValues(w.general.renderTo, category);
                    }
                }
            }
        }
    }
});

// 3. LISTEN - для обновлений UI
visApi().onSelectedValuesChangedListener(
    {
        guid: w.general.renderTo + '-highcharts-listener',
        widgetGuid: w.general.renderTo
    },
    function(event) {
        // Обновляем текущий фильтр из события
        currentFilter = event.selectedValues && event.selectedValues.length > 0
            ? event.selectedValues.map(e => e.join(' - '))[0]
            : '';

        // Обновляем обводку всех точек
        chart.series.forEach((series) => {
            series.data.forEach((point, pointIndex) => {
                point.update({
                    marker: {
                        lineWidth: currentFilter === categories[pointIndex] ? 2 : 0,
                        lineColor: '#000'
                    }
                }, false);
            });
        });

        // Перерисовываем график один раз
        chart.redraw();
    }
);
```

