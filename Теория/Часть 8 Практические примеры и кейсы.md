# Практические примеры и кейсы

## Обработка сложных структур данных для визуализаций

### 1. Treemap (древовидная карта)

**Структура данных для Treemap:**
```javascript
// Целевая структура для ECharts Treemap
{
  name: 'root',
  children: [
    {
      name: 'Category A',
      value: 100,
      children: [
        { name: 'Sub A1', value: 60 },
        { name: 'Sub A2', value: 40 }
      ]
    },
    {
      name: 'Category B', 
      value: 200,
      children: [
        { name: 'Sub B1', value: 120 },
        { name: 'Sub B2', value: 80 }
      ]
    }
  ]
}
```

**Парсинг данных из Visiology:**
```javascript
function parseDataForTreemap(widgetData) {
    const items = widgetData.data.primaryData.items;
    
    // Создаем корневой элемент
    const root = {
        name: 'Все данные',
        children: []
    };
    
    // Группируем по уровням иерархии
    const nodeMap = new Map();
    
    items.forEach(item => {
        let parentNode = root;
        
        // Проходим по всем уровням иерархии
        item.keys.forEach((key, levelIndex) => {
            const path = item.keys.slice(0, levelIndex + 1);
            const pathKey = path.join('|');
            
            if (!nodeMap.has(pathKey)) {
                const newNode = {
                    name: item.formattedKeys[levelIndex],
                    value: 0,
                    path: [...path],
                    pathString: item.formattedKeys.slice(0, levelIndex + 1).join(' - '),
                    children: []
                };
                
                nodeMap.set(pathKey, newNode);
                parentNode.children.push(newNode);
            }
            
            parentNode = nodeMap.get(pathKey);
            
            // Для конечного узла добавляем значение
            if (levelIndex === item.keys.length - 1) {
                parentNode.value = item.values[0]; // Первая метрика
            }
        });
    });
    
    // Вычисляем значения для родительских узлов (сумма дочерних)
    function calculateParentValues(node) {
        if (node.children && node.children.length > 0) {
            node.value = node.children.reduce((sum, child) => {
                return sum + (calculateParentValues(child) || 0);
            }, 0);
        }
        return node.value || 0;
    }
    
    calculateParentValues(root);
    return root;
}

// Использование
const treemapData = parseDataForTreemap(w);
console.log('Treemap data:', treemapData);
```

### 2. Scatter Plot (диаграмма рассеяния)

**Структура данных для Scatter Plot:**
```javascript
// Целевая структура для scatter plot
[
  {
    name: 'Category A',
    data: [
      [10, 20], // [x, y]
      [15, 25],
      [20, 30]
    ]
  },
  {
    name: 'Category B', 
    data: [
      [5, 15],
      [10, 20],
      [15, 25]
    ]
  }
]
```

**Парсинг данных из Visiology:**
```javascript
function parseDataForScatterPlot(widgetData) {
    const items = widgetData.data.primaryData.items;
    const firstItem = items[0];
    
    // Определяем метрики для осей X и Y
    const metrics = firstItem.cols.slice(firstItem.keys.length);
    
    // Если меньше 2 метрик, нельзя построить scatter plot
    if (metrics.length < 2) {
        throw new Error('Need at least 2 metrics for scatter plot');
    }
    
    // Группируем по категориям (первое измерение)
    const seriesMap = new Map();
    
    items.forEach(item => {
        const category = item.formattedKeys[0]; // Первая категория
        const xValue = item.values[0]; // Первая метрика - ось X
        const yValue = item.values[1]; // Вторая метрика - ось Y
        
        if (!seriesMap.has(category)) {
            seriesMap.set(category, {
                name: category,
                data: []
            });
        }
        
        // Добавляем точку данных
        seriesMap.get(category).data.push({
            x: xValue,
            y: yValue,
            name: item.formattedKeys.join(' - '),
            item: item // Сохраняем исходные данные для tooltip
        });
    });
    
    return Array.from(seriesMap.values());
}

// Альтернативная версия для Highcharts
function parseDataForScatterPlotHighcharts(widgetData) {
    const items = widgetData.data.primaryData.items;
    const metrics = items[0].cols.slice(items[0].keys.length);
    
    const series = [];
    
    // Создаем серии для каждой категории
    const categories = [...new Set(items.map(item => item.formattedKeys[0]))];
    
    categories.forEach(category => {
        const categoryData = items.filter(item => item.formattedKeys[0] === category);
        
        series.push({
            name: category,
            data: categoryData.map(item => [
                item.values[0], // x
                item.values[1], // y
                item.formattedKeys.join(' - '), // name
                item.values[2] || 0 // z (для bubble chart)
            ])
        });
    });
    
    return {
        series: series,
        xAxis: { title: { text: metrics[0] } },
        yAxis: { title: { text: metrics[1] } }
    };
}
```

### 3. Sunburst (солнечные лучи)

**Парсинг для Sunburst:**
```javascript
function parseDataForSunburst(widgetData) {
    const items = widgetData.data.primaryData.items;
    
    const root = {
        name: 'root',
        children: []
    };
    
    items.forEach(item => {
        let currentLevel = root;
        
        item.keys.forEach((key, levelIndex) => {
            const levelName = item.formattedKeys[levelIndex];
            const existingChild = currentLevel.children.find(child => child.name === levelName);
            
            if (existingChild) {
                currentLevel = existingChild;
            } else {
                const newChild = {
                    name: levelName,
                    value: levelIndex === item.keys.length - 1 ? item.values[0] : 0,
                    path: item.keys.slice(0, levelIndex + 1),
                    children: []
                };
                
                currentLevel.children.push(newChild);
                currentLevel = newChild;
            }
            
            // Для последнего уровня устанавливаем значение
            if (levelIndex === item.keys.length - 1) {
                currentLevel.value = item.values[0];
            }
        });
    });
    
    // Удаляем пустые children arrays у листьев
    function cleanStructure(node) {
        if (node.children && node.children.length === 0) {
            delete node.children;
        } else if (node.children) {
            node.children.forEach(cleanStructure);
        }
        return node;
    }
    
    return cleanStructure(root);
}
```

### 4. Network Graph (граф связей)

**Парсинг для Network Graph:**
```javascript
function parseDataForNetworkGraph(widgetData) {
    const items = widgetData.data.primaryData.items;
    
    // Предполагаем структуру: [источник, цель, вес]
    const nodes = new Map();
    const links = [];
    
    items.forEach(item => {
        if (item.keys.length >= 2) {
            const source = item.formattedKeys[0];
            const target = item.formattedKeys[1];
            const value = item.values[0] || 1;
            
            // Добавляем узлы
            if (!nodes.has(source)) {
                nodes.set(source, { 
                    id: source, 
                    name: source,
                    value: 0 
                });
            }
            
            if (!nodes.has(target)) {
                nodes.set(target, { 
                    id: target, 
                    name: target,
                    value: 0 
                });
            }
            
            // Добавляем связь
            links.push({
                source: source,
                target: target,
                value: value
            });
            
            // Обновляем веса узлов
            nodes.get(source).value += value;
            nodes.get(target).value += value;
        }
    });
    
    return {
        nodes: Array.from(nodes.values()),
        links: links
    };
}
```

### 5. Parallel Coordinates (параллельные координаты)

**Парсинг для Parallel Coordinates:**
```javascript
function parseDataForParallelCoordinates(widgetData) {
    const items = widgetData.data.primaryData.items;
    const firstItem = items[0];
    
    const dimensions = firstItem.cols.slice(firstItem.keys.length);
    const categories = [...new Set(items.map(item => item.formattedKeys[0]))];
    
    const series = categories.map(category => {
        const categoryItems = items.filter(item => item.formattedKeys[0] === category);
        
        return {
            name: category,
            type: 'parallel',
            lineStyle: {
                width: 1,
                opacity: 0.5
            },
            data: categoryItems.map(item => item.values)
        };
    });
    
    const parallelAxis = dimensions.map((dimension, index) => ({
        dim: index,
        name: dimension,
        type: 'value'
    }));
    
    return {
        parallelAxis: parallelAxis,
        series: series
    };
}
```

## Универсальные утилиты для парсинга

### 1. Анализатор структуры данных
```javascript
function analyzeDataStructure(widgetData) {
    const items = widgetData.data.primaryData.items;
    
    if (!items || items.length === 0) {
        return { error: 'No data available' };
    }
    
    const firstItem = items[0];
    
    return {
        totalItems: items.length,
        dimensions: {
            count: firstItem.keys.length,
            names: firstItem.cols.slice(0, firstItem.keys.length),
            sample: firstItem.formattedKeys
        },
        metrics: {
            count: firstItem.values.length,
            names: firstItem.cols.slice(firstItem.keys.length),
            sample: firstItem.formattedValues
        },
        hierarchy: {
            hasHierarchy: firstItem.keys.length > 1,
            maxDepth: firstItem.keys.length,
            uniqueValuesPerLevel: firstItem.keys.map((_, level) => 
                new Set(items.map(item => item.keys[level])).size
            )
        },
        recommendations: getVisualizationRecommendations(items)
    };
}

function getVisualizationRecommendations(items) {
    const firstItem = items[0];
    const dimensionCount = firstItem.keys.length;
    const metricCount = firstItem.values.length;
    
    const recommendations = [];
    
    if (dimensionCount === 1 && metricCount === 1) {
        recommendations.push('Bar Chart', 'Pie Chart', 'Donut Chart');
    }
    
    if (dimensionCount === 1 && metricCount >= 2) {
        recommendations.push('Multi-series Bar Chart', 'Line Chart', 'Radar Chart');
    }
    
    if (dimensionCount >= 2 && metricCount >= 2) {
        recommendations.push('Treemap', 'Sunburst', 'Scatter Plot');
    }
    
    if (dimensionCount >= 3 && metricCount >= 1) {
        recommendations.push('Hierarchical Charts', 'Sankey Diagram');
    }
    
    return recommendations;
}
```

### 2. Универсальный конвертер
```javascript
class DataParser {
    constructor(widgetData) {
        this.widgetData = widgetData;
        this.items = widgetData.data.primaryData.items;
        this.structure = this.analyzeStructure();
    }
    
    analyzeStructure() {
        const firstItem = this.items[0];
        return {
            dimensions: firstItem.cols.slice(0, firstItem.keys.length),
            metrics: firstItem.cols.slice(firstItem.keys.length),
            hasHierarchy: firstItem.keys.length > 1
        };
    }
    
    forTreemap() {
        return parseDataForTreemap(this.widgetData);
    }
    
    forScatterPlot(xMetricIndex = 0, yMetricIndex = 1) {
        const series = [];
        const categories = [...new Set(this.items.map(item => item.formattedKeys[0]))];
        
        categories.forEach(category => {
            const categoryData = this.items.filter(item => item.formattedKeys[0] === category);
            
            series.push({
                name: category,
                data: categoryData.map(item => ({
                    x: item.values[xMetricIndex],
                    y: item.values[yMetricIndex],
                    name: item.formattedKeys.join(' - '),
                    item: item
                }))
            });
        });
        
        return {
            series: series,
            xAxis: this.structure.metrics[xMetricIndex],
            yAxis: this.structure.metrics[yMetricIndex]
        };
    }
    
    forSunburst() {
        return parseDataForSunburst(this.widgetData);
    }
    
    forNetworkGraph(sourceLevel = 0, targetLevel = 1) {
        const nodes = new Map();
        const links = [];
        
        this.items.forEach(item => {
            if (item.keys.length > Math.max(sourceLevel, targetLevel)) {
                const source = item.formattedKeys[sourceLevel];
                const target = item.formattedKeys[targetLevel];
                const value = item.values[0] || 1;
                
                if (!nodes.has(source)) nodes.set(source, { id: source, name: source, value: 0 });
                if (!nodes.has(target)) nodes.set(target, { id: target, name: target, value: 0 });
                
                links.push({ source: source, target: target, value: value });
                
                nodes.get(source).value += value;
                nodes.get(target).value += value;
            }
        });
        
        return { nodes: Array.from(nodes.values()), links: links };
    }
}

// Использование
const parser = new DataParser(w);
const treemapData = parser.forTreemap();
const scatterData = parser.forScatterPlot(0, 1);
const analysis = parser.structure;

console.log('Data analysis:', analysis);
console.log('Treemap ready:', treemapData);
```

## Практические примеры использования

### Пример 1: Treemap с фильтрацией
```javascript
function createInteractiveTreemap(widgetData, containerId) {
    const parser = new DataParser(widgetData);
    const treemapData = parser.forTreemap();
    
    // Создаем визуализацию
    const chart = echarts.init(document.getElementById(containerId));
    
    const option = {
        series: [{
            type: 'treemap',
            data: [treemapData],
            levels: [/* ... настройки уровней ... */],
            roam: false
        }]
    };
    
    chart.setOption(option);
    
    // Обработчик клика для фильтрации
    chart.on('click', function(params) {
        if (params.data.path) {
            visApi().setFilterSelectedValues(w.general.renderTo, [params.data.path]);
        }
    });
    
    return chart;
}
```

### Пример 2: Scatter Plot с категориями
```javascript
function createScatterPlotWithCategories(widgetData, containerId) {
    const parser = new DataParser(widgetData);
    const scatterData = parser.forScatterPlot(0, 1);
    
    const chart = Highcharts.chart(containerId, {
        chart: { type: 'scatter' },
        title: { text: `${scatterData.xAxis} vs ${scatterData.yAxis}` },
        xAxis: { title: { text: scatterData.xAxis } },
        yAxis: { title: { text: scatterData.yAxis } },
        series: scatterData.series
    });
    
    return chart;
}
```

Эти примеры показывают, как эффективно преобразовывать данные из Visiology в структуры, подходящие для сложных визуализаций, сохраняя при этом возможность фильтрации и интерактивности.